<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async-graphql Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Async-graphql Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="typesystem.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="define_simple_object.html"><strong aria-hidden="true">3.1.</strong> SimpleObject</a></li><li class="chapter-item expanded "><a href="define_complex_object.html"><strong aria-hidden="true">3.2.</strong> Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">3.2.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.2.2.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="merging_objects.html"><strong aria-hidden="true">3.2.3.</strong> Merging Objects / Subscriptions</a></li></ol></li><li class="chapter-item expanded "><a href="define_enum.html"><strong aria-hidden="true">3.3.</strong> Enum</a></li><li class="chapter-item expanded "><a href="define_interface.html"><strong aria-hidden="true">3.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="define_union.html"><strong aria-hidden="true">3.5.</strong> Union</a></li><li class="chapter-item expanded "><a href="define_input_object.html"><strong aria-hidden="true">3.6.</strong> InputObject</a></li><li class="chapter-item expanded "><a href="default_value.html"><strong aria-hidden="true">3.7.</strong> Default value</a></li></ol></li><li class="chapter-item expanded "><a href="define_schema.html"><strong aria-hidden="true">4.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_and_mutation.html"><strong aria-hidden="true">4.1.</strong> Query and Mutation</a></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">4.2.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="sdl_export.html"><strong aria-hidden="true">4.3.</strong> SDL Export</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">5.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="field_guard.html"><strong aria-hidden="true">5.1.</strong> Field guard</a></li><li class="chapter-item expanded "><a href="input_value_validators.html"><strong aria-hidden="true">5.2.</strong> Input value validators</a></li><li class="chapter-item expanded "><a href="cache_control.html"><strong aria-hidden="true">5.3.</strong> Cache control</a></li><li class="chapter-item expanded "><a href="cursor_connections.html"><strong aria-hidden="true">5.4.</strong> Cursor connections</a></li><li class="chapter-item expanded "><a href="error_extensions.html"><strong aria-hidden="true">5.5.</strong> Error extensions</a></li><li class="chapter-item expanded "><a href="apollo_tracing.html"><strong aria-hidden="true">5.6.</strong> Apollo Tracing</a></li><li class="chapter-item expanded "><a href="depth_and_complexity.html"><strong aria-hidden="true">5.7.</strong> Query complexity and depth</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.8.</strong> Hide content in introspection</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">6.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations_to_tide.html"><strong aria-hidden="true">6.1.</strong> Tide</a></li><li class="chapter-item expanded "><a href="integrations_to_warp.html"><strong aria-hidden="true">6.2.</strong> Warp</a></li><li class="chapter-item expanded "><a href="integrations_to_actix_web.html"><strong aria-hidden="true">6.3.</strong> Actix-web</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">7.</strong> Advanced topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_scalars.html"><strong aria-hidden="true">7.1.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="dataloader.html"><strong aria-hidden="true">7.2.</strong> Optimizing N+1 queries</a></li><li class="chapter-item expanded "><a href="custom_extensions.html"><strong aria-hidden="true">7.3.</strong> Custom extensions</a></li><li class="chapter-item expanded "><a href="apollo_federation.html"><strong aria-hidden="true">7.4.</strong> Apollo Federation</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Async-graphql Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>Async-graphql</code> is a GraphQL server-side library implemented in Rust. It is fully compatible with the GraphQL specification and most of its extensions, and offers type safety and high performance.</p>
<p>You can define a Schema in Rust and procedural macros will automatically generate code for a GraphQL query. This library does not extend Rust's syntax, which means that Rustfmt can be used normally. I value this highly and it is one of the reasons why I developed <code>Async-graphql</code>.</p>
<h2 id="why-do-this"><a class="header" href="#why-do-this">Why do this?</a></h2>
<p>I like GraphQL and Rust. I've been using <code>Juniper</code>, which solves the problem of implementing a GraphQL server with Rust. But Juniper had several problems, the most important of which is that it didn't support async/await at the time. So I decided to make this library for myself.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Ensure that there is no CPU-heavy process in background!</p>
<pre><code class="language-shell script">cd benchmark
cargo bench
</code></pre>
<p>Now a HTML report is available at <code>benchmark/target/criterion/report</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="add-dependency-libraries"><a class="header" href="#add-dependency-libraries">Add dependency libraries</a></h2>
<pre><code class="language-toml">[dependencies]
async-graphql = &quot;2.0&quot;
async-graphql-actix-web = &quot;2.0&quot; # If you need to integrate into actix-web
async-graphql-warp = &quot;2.0&quot; # If you need to integrate into warp
async-graphql-tide = &quot;2.0&quot; # If you need to integrate into tide
</code></pre>
<h2 id="write-a-schema"><a class="header" href="#write-a-schema">Write a Schema</a></h2>
<p>The Schema of a GraphQL contains a required Query, an optional Mutation, and an optional Subscription. These object types are described using the structure of the Rust language. The field of the structure corresponds to the field of the GraphQL object.</p>
<p><code>Async-graphql</code> implements the mapping of common data types to GraphQL types, such as <code>i32</code>, <code>f64</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. Also, you can <a href="custom_scalars.html">extend these base types</a>, which are called scalars in the GraphQL.</p>
<p>Here is a simple example where we provide just one query that returns the sum of <code>a</code> and <code>b</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    /// Returns the sum of a and b
    async fn add(&amp;self, a: i32, b: i32) -&gt; i32 {
        a + b
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="execute-the-query"><a class="header" href="#execute-the-query">Execute the query</a></h2>
<p>In our example, there is only a Query without a Mutation or Subscription, so we create the Schema with <code>EmptyMutation</code> and <code>EmptySubscription</code>, and then call <code>Schema::execute</code> to execute the Query.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(Query, EmptyMutation, EmptySubscription);
let res = schema.execute(&quot;{ add(a: 10, b: 20) }&quot;).await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="output-the-query-results-as-json"><a class="header" href="#output-the-query-results-as-json">Output the query results as JSON</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let json = serde_json::to_string(&amp;res);
<span class="boring">}
</span></code></pre></pre>
<h2 id="web-server-integration"><a class="header" href="#web-server-integration">Web server integration</a></h2>
<p>Please refer to <a href="https://github.com/async-graphql/examples">https://github.com/async-graphql/examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p><code>Async-graphql</code> implements conversions from GraphQL Objects to Rust structs, and it's easy to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpleobject"><a class="header" href="#simpleobject">SimpleObject</a></h1>
<p><code>SimpleObject</code> directly maps all the fields of a struct to GraphQL object. 
If you don't require automatic mapping of fields, see <a href="define_complex_object.html">Object</a>.</p>
<p>The example below defines an object <code>MyObject</code> which includes the fields <code>a</code> and <code>b</code>. <code>c</code> will be not mapped to GraphQL as it is labelled as <code>#[graphql(skip)]</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[derive(SimpleObject)]
struct MyObject {
    /// Value a
    a: i32,

    /// Value b
    b: i32,

    #[graphql(skip)]
    c: i32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="user-defined-resolvers"><a class="header" href="#user-defined-resolvers">User-defined resolvers</a></h2>
<p>Sometimes most of the fields of a GraphQL object simply return the value of the structure member, but a few
fields are calculated. In this case, the <a href="define_complex_object.html">Object</a> macro cannot be used unless you hand-write all the resolvers.</p>
<p>The <code>ComplexObject</code> macro works in conjuction with the <code>SimpleObject</code> macro. The <code>SipmleObject</code> derive macro defines
the non-calculated fields, where as the <code>ComplexObject</code> macro let's you write user-defined resolvers for the calculated fields.</p>
<p>Resolvers added to <code>ComplexObject</code> adhere to the same rules as resolvers of <a href="define_complex_object.html">Object</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
#[graphql(complex)] // NOTE: If you want the `ComplexObject` macro to take effect, this `complex` attribute is required.
struct MyObj {
    a: i32,
    b: i32,
}

#[ComplexObject]
impl MyObj {
    async fn c(&amp;self) -&gt; i32 {
        self.a + self.b     
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-simpleobjects"><a class="header" href="#generic-simpleobjects">Generic <code>SimpleObject</code>s</a></h2>
<p>If you want to reuse an <code>SimpleObject</code> for other types, you can define a generic SimpleObject
and specify how its concrete types should be implemented.</p>
<p>In the following example, two <code>SimpleObject</code> types are created:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
pub struct SomeGenericObject&lt;T: OutputType&gt; {
    field1: Option&lt;T&gt;,
    field2: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: Each generic parameter must implement <code>OutputType</code>, as shown above.</p>
<p>The schema generated is:</p>
<pre><code class="language-gql">type SomeName {
  field1: SomeType
  field2: String!
}

type SomeOtherName {
  field1: SomeOtherType
  field2: String!
}
</code></pre>
<p>In your resolver method or field of another object, use as a normal generic type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
pub struct YetAnotherObject {
    a: SomeGenericObject&lt;SomeType&gt;,
    b: SomeGenericObject&lt;SomeOtherType&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>You can pass multiple generic types to <code>params()</code>, separated by a comma.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<p>Different from <code>SimpleObject</code>, <code>Object</code> must have a resolver defined for each field in its <code>impl</code>.</p>
<p><strong>A resolver function has to be asynchronous. The first argument has to be <code>&amp;self</code>, the second is an optional <code>Context</code> and it is followed by field arguments.</strong></p>
<p>The resolvers is used to get the value of the field. For example, you can query a database and return the result. <strong>The return type of the function is the type of the field.</strong> You can also return a <code>async_graphql::Result</code> to return an error if it occurs. The error message will then be sent to query result.</p>
<p>You may need access to global data in your query, for example a database connection pool.
When creating your <code>Schema</code>, you can use <code>SchemaBuilder::data</code> to configure the global data, and <code>Context::data</code> to configure <code>Context</code> data.
The following <code>value_from_db</code> function shows how to retrieve a database connection from <code>Context</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct MyObject {
    value: i32,
}

#[Object]
impl MyObject {
    async fn value(&amp;self) -&gt; String {
        self.value.to_string()
    }

    async fn value_from_db(
        &amp;self,
        ctx: &amp;Context&lt;'_&gt;,
        #[graphql(desc = &quot;Id of object&quot;)] id: i64
    ) -&gt; Result&lt;String&gt; {
        let conn = ctx.data::&lt;DbPool&gt;()?.take();
        Ok(conn.query_something(id)?.name)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>The main goal of <code>Context</code> is to acquire global data attached to Schema. <strong>Note that if the return value of resolver function is borrowed from <code>Context</code>, you will need to explicitly state the lifetime of the argument.</strong></p>
<p>The following example shows how to borrow data in <code>Context</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn borrow_from_context_data&lt;'ctx&gt;(
        &amp;self,
        ctx: &amp;Context&lt;'ctx&gt;
    ) -&gt; Result&lt;&amp;'ctx String&gt; {
        ctx.data::&lt;String&gt;()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Resolve can return a <code>Result</code>, which has the following definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Any <code>Error</code> that implements <code>std::fmt::Display</code> can be converted to <code>Error</code> and you can extend the error message.</p>
<p>The following example shows how to parse an input string to an integer. When parsing fails, it will return an error and attach an error message.
See the <a href="error_extensions.html">Error Extensions</a> section of this book for more details.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn parse_with_extensions(&amp;self, input: String) -&gt; Result&lt;i32&gt; {
        Ok(&quot;234a&quot;
            .parse()
            .map_err(|err: ParseIntError| err.extend_with(|_| json!({&quot;code&quot;: 400})))?)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merging-objects"><a class="header" href="#merging-objects">Merging Objects</a></h1>
<p>Usually we can create multiple implementations for the same type in Rust, but due to the limitation of procedural macros, we can not create multiple Object implementations for the same type. For example, the following code will fail to compile.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl Query {
    async fn users(&amp;self) -&gt; Vec&lt;User&gt; {
        todo!()
    }
}

#[Object]
impl Query {
    async fn movies(&amp;self) -&gt; Vec&lt;Movie&gt; {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Instead, the <code>#[derive(MergedObject)]</code> macro allows you to split an object's resolvers across multiple modules or files by merging 2 or more <code>#[Object]</code> implementations into one.</p>
<p><strong>Tip:</strong> Every <code>#[Object]</code> needs a unique name, even in a <code>MergedObject</code>, so make sure to give each object you're merging its own name.</p>
<p><strong>Note:</strong> This works for queries and mutations. For subscriptions, see &quot;Merging Subscriptions&quot; below.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object]
impl UserQuery {
    async fn users(&amp;self) -&gt; Vec&lt;User&gt; {
        todo!()
    }
}

#[Object]
impl MovieQuery {
    async fn movies(&amp;self) -&gt; Vec&lt;Movie&gt; {
        todo!()
    }
}

#[derive(MergedObject, Default)]
struct Query(UserQuery, MovieQuery);

let schema = Schema::new(
    Query::default(),
    EmptyMutation,
    EmptySubscription
);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>⚠️ <strong>MergedObject cannot be used in Interface。</strong></p>
</blockquote>
<h1 id="merging-subscriptions"><a class="header" href="#merging-subscriptions">Merging Subscriptions</a></h1>
<p>Along with <code>MergedObject</code>, you can derive <code>MergedSubscription</code> or use <code>#[MergedSubscription]</code> to merge separate <code>#[Subscription]</code> blocks.</p>
<p>Like merging Objects, each subscription block requires a unique name.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Subscription1;

#[Subscription]
impl Subscription1 {
    async fn events1(&amp;self) -&gt; impl Stream&lt;Item = i32&gt; {
        futures::stream::iter(0..10)
    }
}

#[derive(Default)]
struct Subscription2;

#[Subscription]
impl Subscription2 {
    async fn events2(&amp;self) -&gt; impl Stream&lt;Item = i32&gt; {
        futures::stream::iter(10..20)
    }
}

#[derive(MergedSubscription, Default)]
struct Subscription(Subscription1, Subscription2);

let schema = Schema::new(
    Query::default(),
    EmptyMutation,
    Subscription::default()
);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>It's easy to define an <code>Enum</code>, here we have an example:</p>
<p><strong>Async-graphql will automatically change the name of each item to GraphQL's CONSTANT_CASE convention. You can use <code>name</code> to rename.</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

/// One of the films in the Star Wars Trilogy
#[derive(Enum, Copy, Clone, Eq, PartialEq)]
pub enum Episode {
    /// Released in 1977.
    NewHope,

    /// Released in 1980.
    Empire,

    /// Released in 1983.
    #[graphql(name=&quot;AAA&quot;)]
    Jedi,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="wrapping-a-remote-enum"><a class="header" href="#wrapping-a-remote-enum">Wrapping a remote enum</a></h2>
<p>Rust's <a href="https://doc.rust-lang.org/book/traits.html#rules-for-implementing-traits">orphan rule</a> requires that either the 
trait or the type for which you are implementing the trait must be defined in the same crate as the impl, so you cannot 
expose remote enumeration types to GraphQL. In order to provide an <code>Enum</code> type, a common workaround is to create a new 
enum that has parity with the existing, remote enum type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

/// Provides parity with a remote enum type
#[derive(Enum, Copy, Clone, Eq, PartialEq)]
pub enum LocalEnum {
    A,
    B,
    C,
}

/// Conversion interface from remote type to our local GraphQL enum type
impl From&lt;remote_crate::RemoteEnum&gt; for LocalEnum {
    fn from(e: remote_crate::RemoteEnum) -&gt; Self {
        match e {
            remote_crate::RemoteEnum::A =&gt; Self::A,
            remote_crate::RemoteEnum::B =&gt; Self::B,
            remote_crate::RemoteEnum::C =&gt; Self::C,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The process is tedious and requires multiple steps to keep the local and remote enums in sync. <code>Async_graphql</code> provides a handy feature to generate the <code>From&lt;remote_crate::RemoteEnum&gt; for LocalEnum</code> as well as an opposite direction of <code>From&lt;LocalEnum&gt; for remote_crate::RemoteEnum</code> via an additional attribute after deriving <code>Enum</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Enum, Copy, Clone, Eq, PartialEq)]
#[graphql(remote = &quot;remote_crate::RemoteEnum&quot;)]
enum LocalEnum {
    A,
    B,
    C,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">Interface</a></h1>
<p><code>Interface</code> is used to abstract <code>Object</code>s with common fields.
<code>Async-graphql</code> implements it as a wrapper.
The wrapper will forward field resolution to the <code>Object</code> that implements this <code>Interface</code>.
Therefore, the <code>Object</code>'s fields' type and arguments must match with the <code>Interface</code>'s.</p>
<p><code>Async-graphql</code> implements auto conversion from <code>Object</code> to <code>Interface</code>, you only need to call <code>Into::into</code>.</p>
<p>Interface field names are transformed to camelCase for the schema definition.
If you need e.g. a snake_cased GraphQL field name, you can use both the <code>name</code> and <code>method</code> attributes.</p>
<ul>
<li>When <code>name</code> and <code>method</code> exist together, <code>name</code> is the GraphQL field name and the <code>method</code> is the resolver function name.</li>
<li>When only <code>name</code> exists, <code>name.to_camel_case()</code> is the GraphQL field name and the <code>name</code> is the resolver function name.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }

    #[graphql(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Circle&quot;.to_string()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }

    #[graphql(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Square&quot;.to_string()
    }
}

#[derive(Interface)]
#[graphql(
    field(name = &quot;area&quot;, type = &quot;f32&quot;),
    field(name = &quot;scale&quot;, type = &quot;Shape&quot;, arg(name = &quot;s&quot;, type = &quot;f32&quot;)),
    field(name = &quot;short_description&quot;, method = &quot;short_description&quot;, type = &quot;String&quot;)
)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="register-the-interface-manually"><a class="header" href="#register-the-interface-manually">Register the interface manually</a></h2>
<p><code>Async-graphql</code> traverses and registers all directly or indirectly referenced types from <code>Schema</code> in the initialization phase.
If an interface is not referenced, it will not exist in the registry, as in the following example , even if <code>MyObject</code> implements <code>MyInterface</code>,
because <code>MyInterface</code> is not referenced in <code>Schema</code>, the <code>MyInterface</code> type will not exist in the registry.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Interface)]
#[graphql(
    field(name = &quot;name&quot;, type = &quot;String&quot;),
)]
enum MyInterface {
    MyObject(MyObject),
}

#[derive(SimpleObject)]
struct MyObject {
    name: String,
}

struct Query;

#[Object]
impl Query {
    async fn obj(&amp;self) -&gt; MyObject {
        todo!()
    }
}

type MySchema = Schema&lt;Query, EmptyMutation, EmptySubscription&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>You need to manually register the <code>MyInterface</code> type when constructing the <code>Schema</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Schema::build(Query, EmptyMutation, EmptySubscription)
    .register_type::&lt;MyInterface&gt;()
    .finish();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union"><a class="header" href="#union">Union</a></h1>
<p>The definition of a <code>Union</code> is similar to an <code>Interface</code>, <strong>but with no fields allowed.</strong>.
The implementation is quite similar for <code>Async-graphql</code>; from <code>Async-graphql</code>'s perspective, <code>Union</code> is a subset of <code>Interface</code>.</p>
<p>The following example modified the definition of <code>Interface</code> a little bit and removed fields.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }
}

#[derive(Union)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="flattening-nested-unions"><a class="header" href="#flattening-nested-unions">Flattening nested unions</a></h2>
<p>A restriction in GraphQL is the inability to create a union type out of
other union types. All members must be <code>Object</code>. To support nested
unions, we can &quot;flatten&quot; members that are unions, bringing their members up
into the parent union. This is done by applying <code>#[graphql(flatten)]</code> on each
member we want to flatten.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(async_graphql::Union)]
pub enum TopLevelUnion {
    A(A),

    // Will fail to compile unless we flatten the union member
    #[graphql(flatten)]
    B(B),
}

#[derive(async_graphql::SimpleObject)]
pub struct A {
    // ...
}

#[derive(async_graphql::Union)]
pub enum B {
    C(C),
    D(D),
}

#[derive(async_graphql::SimpleObject)]
pub struct C {
    // ...
}

#[derive(async_graphql::SimpleObject)]
pub struct D {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The above example transforms the top-level union into this equivalent:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(async_graphql::Union)]
pub enum TopLevelUnion {
    A(A),
    C(C),
    D(D),
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inputobject"><a class="header" href="#inputobject">InputObject</a></h1>
<p>You can use an <code>Object</code> as an argument, and GraphQL calls it an <code>InputObject</code>.</p>
<p>The definition of <code>InputObject</code> is similar to <a href="define_simple_object.html">SimpleObject</a>, but
<code>SimpleObject</code> can only be used as output and <code>InputObject</code> can only be used as input.</p>
<p>You can add optional <code>#[graphql]</code> attributes to add descriptions or rename the field.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[derive(InputObject)]
struct Coordinate {
    latitude: f64,
    longitude: f64
}

struct Mutation;

#[Object]
impl Mutation {
    async fn users_at_location(&amp;self, coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Writes coordination to database.
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-inputobjects"><a class="header" href="#generic-inputobjects">Generic <code>InputObject</code>s</a></h2>
<p>If you want to reuse an <code>InputObject</code> for other types, you can define a generic InputObject
and specify how its concrete types should be implemented.</p>
<p>In the following example, two <code>InputObject</code> types are created:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(InputObject)]
#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
pub struct SomeGenericInput&lt;T: InputType&gt; {
    field1: Option&lt;T&gt;,
    field2: String
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: Each generic parameter must implement <code>InputType</code>, as shown above.</p>
<p>The schema generated is:</p>
<pre><code class="language-gql">input SomeName {
  field1: SomeType
  field2: String!
}

input SomeOtherName {
  field1: SomeOtherType
  field2: String!
}
</code></pre>
<p>In your resolver method or field of another input object, use as a normal generic type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(InputObject)]
pub struct YetAnotherInput {
    a: SomeGenericInput&lt;SomeType&gt;,
    b: SomeGenericInput&lt;SomeOtherType&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>You can pass multiple generic types to <code>params()</code>, separated by a comma.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-value"><a class="header" href="#default-value">Default value</a></h1>
<p>You can define default values for input value types.
Below are some examples.</p>
<h2 id="object-field"><a class="header" href="#object-field">Object field</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

fn my_default() -&gt; i32 {
    30
}

#[Object]
impl Query {
    // The default value of the value parameter is 0, it will call i32::default()
    fn test1(&amp;self, #[graphql(default)] value: i32) {}

    // The default value of the value parameter is 10
    fn test2(&amp;self, #[graphql(default = 10)] value: i32) {}

    // The default value of the value parameter uses the return result of the my_default function, the value is 30.
    fn test3(&amp;self, #[graphql(default_with = &quot;my_default()&quot;)] value: i32) {}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="interface-field"><a class="header" href="#interface-field">Interface field</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[derive(Interface)]
#[graphql(
    field(name = &quot;test1&quot;, arg(name = &quot;value&quot;, default)),
    field(name = &quot;test2&quot;, arg(name = &quot;value&quot;, default = 10)),
    field(name = &quot;test3&quot;, arg(name = &quot;value&quot;, default_with = &quot;my_default()&quot;)),
)]
enum MyInterface {
    MyObj(MyObj),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="input-object-field"><a class="header" href="#input-object-field">Input object field</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

<span class="boring">derive(InputObject)
</span>struct MyInputObject {
    #[graphql(default)]
    value1: i32,

    #[graphql(default = 10)]
    value2: i32,

    #[graphql(default_with = &quot;my_default()&quot;)]
    value3: i32,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>After defining the basic types, you need to define a schema to combine them. The schema consists of three types: a query object, a mutation object, and a subscription object, where the mutation object and subscription object are optional.</p>
<p>When the schema is created, <code>Async-graphql</code> will traverse all object graphs and register all types. This means that if a GraphQL object is defined but never referenced, this object will not be exposed in the schema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-and-mutation"><a class="header" href="#query-and-mutation">Query and Mutation</a></h1>
<h2 id="query-root-object"><a class="header" href="#query-root-object">Query root object</a></h2>
<p>The query root object is a GraphQL object with a definition similar to other objects. Resolver functions for all fields of the query object are executed concurrently.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn user(&amp;self, username: String) -&gt; Result&lt;Option&lt;User&gt;&gt; {
        // Look up users from the database
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="mutation-root-object"><a class="header" href="#mutation-root-object">Mutation root object</a></h2>
<p>The mutation root object is also a GraphQL object, but it executes sequentially. One mutation following from another will only be executed only after the first mutation is completed.</p>
<p>The following mutation root object provides an example of user registration and login:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Mutation;

#[Object]
impl Mutation {
    async fn signup(&amp;self, username: String, password: String) -&gt; Result&lt;bool&gt; {
        // User signup
    }

    async fn login(&amp;self, username: String, password: String) -&gt; Result&lt;String&gt; {
        // User login (generate token)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscription"><a class="header" href="#subscription">Subscription</a></h1>
<p>The definition of the subscription root object is slightly different from other root objects. Its resolver function always returns a <a href="https://docs.rs/futures-core/%7E0.3/futures_core/stream/trait.Stream.html">Stream</a> or <code>Result&lt;Stream&gt;</code>, and the field parameters are usually used as data filtering conditions.</p>
<p>The following example subscribes to an integer stream, which generates one integer per second. The parameter <code>step</code> specifies the integer step size with a default of 1.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Subscription;

#[Subscription]
impl Subscription {
    async fn integers(&amp;self, #[graphql(default = 1)] step: i32) -&gt; impl Stream&lt;Item = i32&gt; {
        let mut value = 0;
        tokio_stream::wrappers::IntervalStream::new(tokio::time::interval(Duration::from_secs(1)))
            .map(move |_| {
                value += step;
                value
            })
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdl-export"><a class="header" href="#sdl-export">SDL Export</a></h1>
<p>You can export your schema in Schema Definition Language (SDL) by using the <code>Schema::sdl()</code> method.</p>
<pre><pre class="playground"><code class="language-rust">use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn add(&amp;self, u: i32, v: i32) -&gt; i32 {
        u + v
    }
}

#[tokio::main]
async fn main() {
    let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();
    
    // Print the schema in SDL format
    println!(&quot;{}&quot;, &amp;schema.sdl());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-guard"><a class="header" href="#field-guard">Field Guard</a></h1>
<p>You can define <code>guard</code> to field of an <code>Object</code>. This permit to add checks before run the code logic of the field.
<code>Guard</code> are made of rules that you need to define before. A rule is a structure which implement the trait <code>Guard</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq, Copy, Clone)]
enum Role {
    Admin,
    Guest,
}

struct RoleGuard {
    role: Role,
}

#[async_trait::async_trait]
impl Guard for RoleGuard {
    async fn check(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        if ctx.data_opt::&lt;Role&gt;() == Some(&amp;self.role) {
            Ok(())
        } else {
            Err(&quot;Forbidden&quot;.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Once you have defined your rule you can use it in the <code>guard</code> field attribute.
This attribute support 4 operators to create complex rules :</p>
<ul>
<li>
<p><code>and</code> : perform a <code>and</code> operation between two rules. (If one rule return an error the <code>and</code> operator will return the error. If both rules return a error it's the first one that will be returned).</p>
</li>
<li>
<p><code>or</code> : perform a <code>or</code> operation between two rules. (If both rules return an error the error returned is the first one)</p>
</li>
<li>
<p><code>chain</code> : take a set of rules and run them until one return an error or return <code>Ok</code> if all rules pass.</p>
</li>
<li>
<p><code>race</code> : take a set of rules and run them until one return <code>Ok</code> if they all fail it return the last error.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SimpleObject)]
struct Query {
    #[graphql(guard(RoleGuard(role = &quot;Role::Admin&quot;)))]
    value: i32,
    #[graphql(guard(and(
        RoleGuard(role = &quot;Role::Admin&quot;),
        UserGuard(username = r#&quot;&quot;test&quot;&quot;#)
    )))]
    value2: i32,
    #[graphql(guard(or(
        RoleGuard(role = &quot;Role::Admin&quot;),
        UserGuard(username = r#&quot;&quot;test&quot;&quot;#)
    )))]
    value3: i32,
    #[graphql(guard(chain(
        RoleGuard(role = &quot;Role::Admin&quot;),
        UserGuard(username = r#&quot;&quot;test&quot;&quot;#),
        AgeGuard(age = r#&quot;21&quot;#)
    )))]
    value4: i32,
    #[graphql(guard(race(
        RoleGuard(role = &quot;Role::Admin&quot;),
        UserGuard(username = r#&quot;&quot;test&quot;&quot;#),
        AgeGuard(age = r#&quot;21&quot;#)
    )))]
    value5: i32,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-value-validators"><a class="header" href="#input-value-validators">Input value validators</a></h1>
<p>Arguments to a query (<a href="define_input_object.html">InputObject</a>) are called <code>Input Objects</code> in GraphQL. If the provided input type does not match for a query, the query will return a type mismatch error. But sometimes we want to provide more restrictions on specific types of values. For example, we might want to require that an argument is a valid email address. <code>Async-graphql</code> provides an input validators to solve this problem.</p>
<p>An input validator can be combined via <code>and</code> and <code>or</code> operators.</p>
<p>The following is an input validator which checks that a <code>String</code> is a valid Email or MAC address:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::validators::{Email, MAC};

struct Query;

#[Object]
impl Query {
    async fn input(#[graphql(validator(or(Email, MAC(colon = &quot;false&quot;))))] a: String) {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following example verifies that the <code>i32</code> parameter <code>a</code> is greater than 10 and less than 100, or else equal to 0:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::validators::{IntGreaterThan, IntLessThan, IntEqual};

struct Query;

#[Object]
impl Query {
    async fn input(#[graphql(validator(
        or(
            and(IntGreaterThan(value = &quot;10&quot;), IntLessThan(value = &quot;100&quot;)),
            IntEqual(value = &quot;0&quot;)
        )))] a: String) {
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="validate-the-elements-of-the-list"><a class="header" href="#validate-the-elements-of-the-list">Validate the elements of the list.</a></h2>
<p>You can use the <code>list</code> operator to indicate that the internal validator is used for all elements in a list:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::validators::Email;

struct Query;

#[Object]
impl Query {
    async fn input(#[graphql(validator(list(Email)))] emails: Vec&lt;String&gt;) {
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="custom-validator"><a class="header" href="#custom-validator">Custom validator</a></h2>
<p>Here is an example of a custom validator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MustBeZero {}

impl InputValueValidator for MustBeZero {
    fn is_valid(&amp;self, value: &amp;Value) -&gt; Result&lt;(), String&gt; {
        if let Value::Int(n) = value {
            if n.as_i64().unwrap() != 0 {
                // Validation failed
                Err(format!(
                    &quot;the value is {}, but must be zero&quot;,
                    n.as_i64().unwrap(),
                ))
            } else {
                // Validation succeeded
                Ok(())
            }
        } else {
            // If the type does not match we can return None and built-in validations
            // will pick up on the error
            Ok(())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-control"><a class="header" href="#cache-control">Cache control</a></h1>
<p>Production environments often rely on caching to improve performance.</p>
<p>A GraphQL query will call multiple resolver functions and each resolver can have a different cache definition. Some may cache for a few seconds, some may cache for a few hours, some may be the same for all users, and some may be different for each session.</p>
<p><code>Async-graphql</code> provides a mechanism that allows you to define the cache time and scope for each resolver.</p>
<p>You can define cache parameters on the object or on its fields. The following example shows two uses of cache control parameters.</p>
<p>You can use <code>max_age</code> parameters to control the age of the cache (in seconds), and you can also use <code>public</code> and <code>private</code> to control the scope of the cache. When you do not specify it, the scope will default to <code>public</code>.</p>
<p>when querying multiple resolvers, the results of all cache control parameters will be combined and the <code>max_age</code> minimum value will be taken. If the scope of any object or field is <code>private</code>, the result will be <code>private</code>.</p>
<p>We can use <code>QueryResponse</code> to get a merged cache control result from a query result, and call <code>CacheControl::value</code> to get the corresponding HTTP header.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[Object(cache_control(max_age = 60))]
impl Query {
    #[graphql(cache_control(max_age = 30))]
    async fn value1(&amp;self) -&gt; i32 {
    }

    #[graphql(cache_control(private))]
    async fn value2(&amp;self) -&gt; i32 {
    }

    async fn value3(&amp;self) -&gt; i32 {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following are different queries corresponding to different cache control results:</p>
<pre><code class="language-graphql"># max_age=30
{ value1 }
</code></pre>
<pre><code class="language-graphql"># max_age=30, private
{ value1 value2 }
</code></pre>
<pre><code class="language-graphql"># max_age=60
{ value3 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor-connections"><a class="header" href="#cursor-connections">Cursor connections</a></h1>
<p>Relay's cursor connection specification is designed to provide a consistent method for query paging. For more details on the specification see the <a href="https://facebook.github.io/relay/graphql/connections.htm">GraphQL Cursor Connections Specification</a>。</p>
<p>Defining a cursor connection in <code>async-graphql</code> is very simple, you just call the <code>connection::query</code> function and query data in the closure.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::connection::*;

struct Query;

#[Object]
impl Query {
    async fn numbers(&amp;self,
        after: Option&lt;String&gt;,
        before: Option&lt;String&gt;,
        first: Option&lt;i32&gt;,
        last: Option&lt;i32&gt;,
    ) -&gt; Result&lt;Connection&lt;usize, i32, EmptyFields, EmptyFields&gt;&gt; {
        query(after, before, first, last, |after, before, first, last| async move {
            let mut start = after.map(|after| after + 1).unwrap_or(0);
            let mut end = before.unwrap_or(10000);
            if let Some(first) = first {
                end = (start + first).min(end);
            }
            if let Some(last) = last {
                start = if last &gt; end - start {
                     end
                } else {
                    end - last
                };
            }
            let mut connection = Connection::new(start &gt; 0, end &lt; 10000);
            connection.append(
                (start..end).into_iter().map(|n|
                    Ok(Edge::new_with_additional_fields(n, n as i32, EmptyFields)),
            ))?;
            Ok(connection)
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-extensions"><a class="header" href="#error-extensions">Error extensions</a></h1>
<p>To quote the <a href="https://spec.graphql.org/June2018/#example-fce18">graphql-spec</a>:</p>
<blockquote>
<p>GraphQL services may provide an additional entry to errors with key extensions.
This entry, if set, must have a map as its value. This entry is reserved for implementer to add
additional information to errors however they see fit, and there are no additional restrictions on
its contents.</p>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>I would recommend on checking out this <a href="https://github.com/async-graphql/examples/blob/master/actix-web/error-extensions/src/main.rs">async-graphql example</a> as a quickstart.</p>
<h2 id="general-concept"><a class="header" href="#general-concept">General Concept</a></h2>
<p>In <code>async-graphql</code> all user-facing errors are cast to the <code>Error</code> type which by default provides
the error message exposed by <code>std::fmt::Display</code>. However, <code>Error</code> actually provides an additional information that can extend the error.</p>
<p>A resolver looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32, Error&gt; {
    Err(Error::new(&quot;MyMessage&quot;).extend_with(|_, e| e.set(&quot;details&quot;, &quot;CAN_NOT_FETCH&quot;)))
}
<span class="boring">}
</span></code></pre></pre>
<p>may then return a response like this:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;details&quot;: &quot;CAN_NOT_FETCH&quot;,
      }
    }
  ]
}
</code></pre>
<h2 id="errorextensions"><a class="header" href="#errorextensions">ErrorExtensions</a></h2>
<p>Constructing new <code>Error</code>s by hand quickly becomes tedious. That is why <code>async-graphql</code> provides
two convenience traits for casting your errors to the appropriate <code>Error</code> with
extensions.</p>
<p>The easiest way to provide extensions to any error is by calling <code>extend_with</code> on the error.
This will on the fly convert any error into a <code>Error</code> with the given extension.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::num::ParseIntError;
async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .map_err(|err: ParseIntError| err.extend_with(|_err, e| e.set(&quot;code&quot;, 404)))?)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-errorextensions-for-custom-errors"><a class="header" href="#implementing-errorextensions-for-custom-errors">Implementing ErrorExtensions for custom errors.</a></h3>
<p>If you find yourself attaching extensions to your errors all over the place you might want to consider
implementing the trait on your custom error type directly.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate thiserror;

#[derive(Debug, Error)]
pub enum MyError {
    #[error(&quot;Could not find resource&quot;)]
    NotFound,

    #[error(&quot;ServerError&quot;)]
    ServerError(String),

    #[error(&quot;No Extensions&quot;)]
    ErrorWithoutExtensions,
}

impl ErrorExtensions for MyError {
    // lets define our base extensions
    fn extend(&amp;self) -&gt; Error {
        Error::new(format!(&quot;{}&quot;, self)).extend_with(|err, e| 
            match self {
              MyError::NotFound =&gt; e.set(&quot;code&quot;, &quot;NOT_FOUND&quot;),
              MyError::ServerError(reason) =&gt; e.set(&quot;reason&quot;, reason),
              MyError::ErrorWithoutExtensions =&gt; {}
          })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This way you only need to call <code>extend</code> on your error to deliver the error message alongside the provided extensions.
Or further extend your error through <code>extend_with</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // Err(MyError::NotFound.extend())
    // OR
    Err(MyError::NotFound.extend_with(|_, e| e.set(&quot;on_the_fly&quot;, &quot;some_more_info&quot;)))
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;NotFound&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;NOT_FOUND&quot;,
        &quot;on_the_fly&quot;: &quot;some_more_info&quot;
      }
    }
  ]
}
</code></pre>
<h2 id="resultext"><a class="header" href="#resultext">ResultExt</a></h2>
<p>This trait enables you to call <code>extend_err</code> directly on results. So the above code becomes less verbose.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .extend_err(|_, e| e.set(&quot;code&quot;, 404))?)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="chained-extensions"><a class="header" href="#chained-extensions">Chained extensions</a></h3>
<p>Since <code>ErrorExtensions</code> and <code>ResultExt</code> are implemented for any type <code>&amp;E where E: std::fmt::Display</code>
we can chain the extension together.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
    match &quot;234a&quot;.parse() {
        Ok(n) =&gt; Ok(n),
        Err(e) =&gt; Err(e
            .extend_with(|_, e| e.set(&quot;code&quot;, 404))
            .extend_with(|_, e| e.set(&quot;details&quot;, &quot;some more info..&quot;))
            // keys may also overwrite previous keys...
            .extend_with(|_, e| e.set(&quot;code&quot;, 500))),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Expected response:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
      	&quot;details&quot;: &quot;some more info...&quot;,
        &quot;code&quot;: 500,
      }
    }
  ]
}
</code></pre>
<h3 id="pitfalls"><a class="header" href="#pitfalls">Pitfalls</a></h3>
<p>Rust does not provide stable trait specialization yet.
That is why <code>ErrorExtensions</code> is actually implemented for <code>&amp;E where E: std::fmt::Display</code>
instead of <code>E: std::fmt::Display</code>. Some specialization is provided through
<a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">Autoref-based stable specialization</a>.
The disadvantage is that the below code does <strong>NOT</strong> compile:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // the trait `error::ErrorExtensions` is not implemented
    // for `std::num::ParseIntError`
    &quot;234a&quot;.parse().extend_err(|_, e| e.set(&quot;code&quot;, 404))
}
</code></pre>
<p>however this does:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // does work because ErrorExtensions is implemented for &amp;ParseIntError
    &quot;234a&quot;
      .parse()
      .map_err(|ref e: ParseIntError| e.extend_with(|_, e| e.set(&quot;code&quot;, 404)))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apollo-tracing"><a class="header" href="#apollo-tracing">Apollo Tracing</a></h1>
<p>Apollo Tracing provides performance analysis results for each step of query. This is an extension to <code>Schema</code>, and the performance analysis results are stored in <code>QueryResponse</code>.</p>
<p>To enable the Apollo Tracing extension, add the extension when the <code>Schema</code> is created.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::extensions::ApolloTracing;

let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .extension(ApolloTracing) // Enable ApolloTracing extension
    .finish();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-complexity-and-depth"><a class="header" href="#query-complexity-and-depth">Query complexity and depth</a></h1>
<p>⚠️GraphQL provides a powerful way to query your data, but putting great
power in the hands of your API clients also exposes you to a risk of denial 
of service attacks. You can mitigate that risk with <code>Async-graphql</code> by limiting the 
complexity and depth of the queries you allow.</p>
<h2 id="expensive-queries"><a class="header" href="#expensive-queries">Expensive Queries</a></h2>
<p>Consider a schema that allows listing blog posts. Each blog post is also related to other posts.</p>
<pre><code class="language-graphql">type Query {
	posts(count: Int = 10): [Post!]!
}

type Post {
	title: String!
	text: String!
	related(count: Int = 10): [Post!]!
}
</code></pre>
<p>It’s not too hard to craft a query that will cause a very large response:</p>
<pre><code class="language-graphql">{
    posts(count: 100) {
        related(count: 100) {
            related(count: 100) {
                related(count: 100) {
                    title
                }
            }
        }
    }
}
</code></pre>
<p>The size of the response increases exponentially with every other level of the <code>related</code> field. Fortunately, <code>Async-graphql</code> provides 
a way to prevent such queries.</p>
<h2 id="limiting-query-depth"><a class="header" href="#limiting-query-depth">Limiting Query depth</a></h2>
<p>The depth is the number of nesting levels of the field, and the following is a query with a depth of <code>3</code>.</p>
<pre><code class="language-graphql">{
    a {
        b {
            c
        }
    }
}
</code></pre>
<p>You can limit the depth when creating <code>Schema</code>. If the query exceeds this limit, an error will occur and the 
message <code>Query is nested too deep</code> will be returned.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .limit_depth(5) // Limit the maximum depth to 5
    .finish();
<span class="boring">}
</span></code></pre></pre>
<h2 id="limiting-query-complexity"><a class="header" href="#limiting-query-complexity">Limiting Query complexity</a></h2>
<p>The complexity is the number of fields in the query. The default complexity of each field is <code>1</code>. Below is a 
query with a complexity of <code>6</code>.</p>
<pre><code class="language-graphql">{
    a b c {
        d {
            e f
        }
    }
}
</code></pre>
<p>You can limit the complexity when creating the <code>Schema</code>. If the query exceeds this limit, an error will occur 
and <code>Query is too complex</code> will be returned.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .limit_complexity(5) // Limit the maximum complexity to 5
    .finish();
<span class="boring">}
</span></code></pre></pre>
<h2 id="custom-complexity-calculation"><a class="header" href="#custom-complexity-calculation">Custom Complexity Calculation</a></h2>
<p>There are two ways to customize the complexity for non-list type and list type fields.</p>
<p>In the following code, the complexity of the <code>value</code> field is <code>5</code>. The complexity of the <code>values</code> field is <code>count * child_complexity</code>, 
<code>child_complexity</code> is a special variable that represents the complexity of the subquery, and <code>count</code> is the parameter of the field,
used to calculate the complexity of the <code>values</code> field, and the type of the return value must be <code>usize</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Query;

#[Object]
impl Query {
    #[graphql(complexity = 5)]
    async fn value(&amp;self) -&gt; i32 {
        todo!()
    }

    #[graphql(complexity = &quot;count * child_complexity&quot;)]
    async fn values(&amp;self, count: usize) -&gt; i32 {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note: The complexity calculation is done in the validation phase and not in the execution phase, so you don't have to worry about the query 
over-limit causing the execute only part of the query.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hide-content-in-introspection"><a class="header" href="#hide-content-in-introspection">Hide content in introspection</a></h1>
<p>By default, all types and fields are visible in introspection. But maybe you want to hide some content according to different users to avoid unnecessary misunderstandings. You can add the <code>visible</code> attribute to the type or field to do it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[derive(SimpleObject)]
struct MyObj {
    // This field will be visible in introspection.
    a: i32,

    // This field is always hidden in introspection.
    #[graphql(visible = false)]
    b: i32,

    // This field calls the `is_admin` function, which 
    // is visible if the return value is `true`.
    #[graphql(visible = &quot;is_admin&quot;)]
    c: i32,
}

#[derive(Enum)]
enum MyEnum {
    // This item will be visible in introspection.
    A,

    // This item is always hidden in introspection.
    #[graphql(visible = false)]
    B,

    // This item calls the `is_admin` function, which 
    // is visible if the return value is `true`.
    #[graphql(visible = &quot;is_admin&quot;)]
    C,
}

struct IsAdmin(bool);

fn is_admin(ctx: &amp;Context&lt;'_&gt;) -&gt; bool {
    ctx.data_unchecked::&lt;IsAdmin&gt;().0
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<p><code>Async-graphql</code> supports several common Rust web servers.</p>
<ul>
<li>Actix-web <a href="https://crates.io/crates/async-graphql-actix-web">async-graphql-actix-web</a></li>
<li>Warp <a href="https://crates.io/crates/async-graphql-warp">async-graphql-warp</a></li>
<li>Tide <a href="https://crates.io/crates/async-graphql-tide">async-graphql-tide</a></li>
<li>Rocket <a href="https://github.com/async-graphql/async-graphql/tree/master/integrations/rocket">async-graphql-rocket</a></li>
</ul>
<p><strong>Even if the server you are currently using is not in the above list, it is quite simple to implement similar functionality yourself.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tide"><a class="header" href="#tide">Tide</a></h1>
<p><code>async_graphql_tide</code> provides an implementation of <a href="https://docs.rs/tide/0.15.0/tide/trait.Endpoint.html">tide::Endpoint</a> trait. It also provides <code>receive_request</code> and <code>respond</code> functions to convert a Tide request to a GraphQL request and back to Tide response, if you want to  handle the request manually.</p>
<h2 id="request-example"><a class="header" href="#request-example">Request example</a></h2>
<p>When you create your <code>tide</code> server, you will need to pass the <code>async_graphql_tide::endpoint</code> with your schema as the POST request handler. Please note that you need to enable the <code>attributes</code> feature in <code>async-std</code> for this example to work.</p>
<pre><pre class="playground"><code class="language-rust">use async_graphql::{
    http::{playground_source, GraphQLPlaygroundConfig},
    Context, EmptyMutation, EmptySubscription, Object, Schema, SimpleObject,
};
use tide::{http::mime, Body, Response, StatusCode};

#[derive(SimpleObject)]
pub struct Demo {
    pub id: usize,
}

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn demo(&amp;self, _ctx: &amp;Context&lt;'_&gt;) -&gt; Demo {
        Demo { id: 42 }
    }
}

#[async_std::main]
async fn main() -&gt; tide::Result&lt;()&gt; {
    let mut app = tide::new();

    // create schema
    let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription).finish();

    // add tide endpoint
    app.at(&quot;/graphql&quot;)
        .post(async_graphql_tide::endpoint(schema));

    // enable graphql playground
    app.at(&quot;/&quot;).get(|_| async move {
        Ok(Response::builder(StatusCode::Ok)
            .body(Body::from_string(playground_source(
                // note that the playground needs to know
                // the path to the graphql endpoint
                GraphQLPlaygroundConfig::new(&quot;/graphql&quot;),
            )))
            .content_type(mime::HTML)
            .build())
    });

    Ok(app.listen(&quot;127.0.0.1:8080&quot;).await?)
}
</code></pre></pre>
<h2 id="manually-handle-the-request"><a class="header" href="#manually-handle-the-request">Manually handle the request</a></h2>
<p>If you want to manually handle the request, for example to read a header, you can skip <code>async_graphql_tide::endpoint</code> and use <code>receive_request</code> and <code>respond</code> functions instead.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>app.at(&quot;/graphql&quot;).post(move |req: tide::Request&lt;()&gt;| {
    let schema = schema.clone();
    async move {
        let req = async_graphql_tide::receive_request(req).await?;
        async_graphql_tide::respond(schema.execute(req).await)
    }
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/tide">https://github.com/async-graphql/examples/tree/master/tide</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="warp"><a class="header" href="#warp">Warp</a></h1>
<p>For <code>Async-graphql-warp</code>, two <code>Filter</code> integrations are provided: <code>graphql</code> and <code>graphql_subscription</code>.</p>
<p>The <code>graphql</code> filter is used for execution <code>Query</code> and <code>Mutation</code> requests. It always asks for the POST method and outputs a <code>async_graphql::Schema</code> and <code>async_graphql::Request</code>.
You can combine other filters later, or directly call <code>Schema::execute</code> to execute the query.</p>
<p><code>graphql_subscription</code> is used to implement WebSocket subscriptions. It outputs <code>warp::Reply</code>.</p>
<h2 id="request-example-1"><a class="header" href="#request-example-1">Request example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MySchema = Schema&lt;QueryRoot, EmptyMutation, EmptySubscription&gt;;

let schema = Schema::new(QueryRoot, EmptyMutation, EmptySubscription);
let filter = async_graphql_warp::graphql(schema).and_then(|(schema, request): (MySchema, async_graphql::Request)| async move {
    // Execute query
    let resp = schema.execute(request).await;

    // Return result
    Ok::&lt;_, Infallible&gt;(async_graphql_warp::Response::from(resp))
});
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="subscription-example"><a class="header" href="#subscription-example">Subscription example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let filter = async_graphql_warp::graphql_subscription(schema);
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h2 id="more-examples-1"><a class="header" href="#more-examples-1">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/warp">https://github.com/async-graphql/examples/tree/master/warp</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actix-web"><a class="header" href="#actix-web">Actix-web</a></h1>
<p><code>Async-graphql-actix-web</code> provides an implementation of <code>actix_web::FromRequest</code> for <code>Request</code>.
This is actually an abstraction around <code>async_graphql::Request</code> and you can call <code>Request::into_inner</code> to 
convert it into a <code>async_graphql::Request</code>.</p>
<p><code>WSSubscription</code> is an Actor that supports WebSocket subscriptions.</p>
<h2 id="request-example-2"><a class="header" href="#request-example-2">Request example</a></h2>
<p>When you define your <code>actix_web::App</code> you need to pass in the Schema as data. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn index(
    // Schema now accessible here
    schema: web::Data&lt;Schema&gt;,
    request: async_graphql_actix_web::Request,
) -&gt; web::Json&lt;Response&gt; {
    web::Json(Response(schema.execute(request.into_inner()).await)
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="subscription-example-1"><a class="header" href="#subscription-example-1">Subscription example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn index_ws(
    schema: web::Data&lt;Schema&gt;,
    req: HttpRequest,
    payload: web::Payload,
) -&gt; Result&lt;HttpResponse&gt; {
    WSSubscription::start(Schema::clone(&amp;*schema), &amp;req, payload)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="more-examples-2"><a class="header" href="#more-examples-2">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/actix-web">https://github.com/async-graphql/examples/tree/master/actix-web</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced topics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-scalars"><a class="header" href="#custom-scalars">Custom scalars</a></h1>
<p>In <code>Async-graphql</code> most common scalar types are built in, but you can also create your own scalar types.</p>
<p>Using <code>async-graphql::Scalar</code>, you can add support for a scalar when you implement it. You only need to implement parsing and output functions.</p>
<p>The following example defines a 64-bit integer scalar where its input and output are strings. (Note: <code>Async-graphql</code> already supports 64-bit integers and uses strings as input and output.)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct StringNumber(i64);

#[Scalar]
impl ScalarType for StringNumber {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        if let Value::String(value) = &amp;value {
            // Parse the integer value
            Ok(value.parse().map(StringNumber)?)
        } else {
            // If the type does not match
            Err(InputValueError::expected_type(value))
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(self.0.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="use-scalar-macro-to-define-scalar"><a class="header" href="#use-scalar-macro-to-define-scalar">Use <code>scalar!</code> macro to define scalar</a></h2>
<p>If your type implemented <code>serde::Serialize</code> and <code>serde::Deserialize</code>, then you can use this macro to define a scalar more simply.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct MyValue {
    a: i32,
    b: HashMap&lt;String, i32&gt;,     
}

scalar!(MyValue);

// Rename to `MV`.
// scalar!(MyValue, &quot;MV&quot;);

// Rename to `MV` and add description.
// scalar!(MyValue, &quot;MV&quot;, &quot;This is my value&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-n1-queries"><a class="header" href="#optimizing-n1-queries">Optimizing N+1 queries</a></h1>
<p>Have you noticed some GraphQL queries end can make hundreds of database queries, often with mostly repeated data? Lets take a look why and how to fix it.</p>
<h2 id="query-resolution"><a class="header" href="#query-resolution">Query Resolution</a></h2>
<p>Imagine if you have a simple query like this:</p>
<pre><code class="language-graphql">query { todos { users { name } } }
</code></pre>
<p>and <code>User</code> resolver is like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    id: u64,
}

#[Object]
impl User {
    async fn name(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;String&gt; {
        let pool = ctx.data_unchecked::&lt;Pool&lt;Postgres&gt;&gt;();
        let (name,): (String,) = sqlx::query_as(&quot;SELECT name FROM user WHERE id = $1&quot;)
            .bind(self.id)
            .fetch_one(pool)
            .await?;
        Ok(name)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The query executor will call the <code>Todos</code> resolver which does a <code>select * from todo and return N todos</code>. Then for each 
of the todos, concurrently, call the <code>User</code> resolver, <code>SELECT from USER where id = todo.user_id</code>.</p>
<p>eg：</p>
<pre><code class="language-sql">SELECT id, todo, user_id FROM todo
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
</code></pre>
<p>After executing <code>SELECT name FROM user WHERE id = $1</code> many times, and most <code>Todo</code> objects belong to the same user, we 
need to optimize these codes!</p>
<h2 id="dataloader"><a class="header" href="#dataloader">Dataloader</a></h2>
<p>We need to group queries and exclude duplicate queries. <code>Dataloader</code> can do this.
<a href="https://github.com/facebook/dataloader">facebook</a> gives a request-scope batch and caching solution.</p>
<p>The following is an example of using <code>DataLoader</code> to optimize queries::</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::dataloader::*;
use itertools::Itertools;

struct UserNameLoader {
    pool: sqlx::Pool&lt;Postgres&gt;,
}

#[async_trait::async_trait]
impl Loader&lt;u64&gt; for UserNameLoader {
    type Value = String;
    type Error = sqlx::Error;

    async fn load(&amp;self, keys: &amp;[u64]) -&gt; Result&lt;HashMap&lt;u64, Self::Value&gt;, Self::Error&gt; {
        let pool = ctx.data_unchecked::&lt;Pool&lt;Postgres&gt;&gt;();
        let query = format!(&quot;SELECT name FROM user WHERE id IN ({})&quot;, keys.iter().join(&quot;,&quot;));
        Ok(sqlx::query_as(query)
            .fetch(&amp;self.pool)
            .map_ok(|name: String| name)
            .try_collect().await?)
    }
}

struct User {
    id: u64,
}

#[Object]
impl User {
    async fn name(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;String&gt; {
        let loader = ctx.data_unchecked::&lt;DataLoader&lt;UserNameLoader&gt;&gt;();
        let name: Option&lt;String&gt; = loader.load_one(self.id).await?;
        name.ok_or_else(|| &quot;Not found&quot;.into())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the end, only two SQLs are needed to query the results we want!</p>
<pre><code class="language-sql">SELECT id, todo, user_id FROM todo
SELECT name FROM user WHERE id IN (1, 2, 3, 4)
</code></pre>
<h2 id="implement-multiple-data-types"><a class="header" href="#implement-multiple-data-types">Implement multiple data types</a></h2>
<p>You can implement multiple data types for the same <code>Loader</code>, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PostgresLoader {
    pool: sqlx::Pool&lt;Postgres&gt;,
}

#[async_trait::async_trait]
impl Loader&lt;UserId&gt; for PostgresLoader {
    type Value = User;
    type Error = sqlx::Error;

    async fn load(&amp;self, keys: &amp;[UserId]) -&gt; Result&lt;HashMap&lt;UserId, Self::Value&gt;, Self::Error&gt; {
        // Load users from database
    }
}

#[async_trait::async_trait]
impl Loader&lt;TodoId&gt; for PostgresLoader {
    type Value = Todo;
    type Error = sqlx::Error;

    async fn load(&amp;self, keys: &amp;[TodoId]) -&gt; Result&lt;HashMap&lt;TodoId, Self::Value&gt;, Self::Error&gt; {
        // Load todos from database
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-extensions"><a class="header" href="#custom-extensions">Custom extensions</a></h1>
<p>A GraphQL extension object can receive events in various stages of a query's execution, and you can collect various kinds of data to be returned in the query results.</p>
<p>You can use <code>async_graphql::Extension</code> to define an extension object, and your application must call <code>Schema::extension</code> when your <code>Schema</code> is created.</p>
<p>You can refer to <a href="https://github.com/async-graphql/async-graphql/blob/master/src/extensions/tracing.rs">Apollo Tracing</a> to implement your own extension types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apollo-federation"><a class="header" href="#apollo-federation">Apollo Federation</a></h1>
<p><code>Apollo Federation</code> is a <code>GraphQL</code> API gateway which can combine multiple GraphQL services, allowing each service to implement the subset of the API it is responsible for. You can read more in the <a href="https://www.apollographql.com/docs/apollo-server/federation/introduction">official documentation</a>.</p>
<p><code>Async-graphql</code> supports all the functionality of <code>Apollo Federation</code>, but some modifications to your <code>Schema</code> are required.</p>
<ul>
<li>
<p>You can use the <code>extends</code> property declaration on <code>async_graphql::Object</code> and <code>async_graphql::Interface</code> to extend a type offered by another implementing service.</p>
</li>
<li>
<p>The <code>external</code> property declares that a field comes from another service。</p>
</li>
<li>
<p>The <code>provides</code> directive is used to annotate the expected returned fieldset from a field on a base type that is guaranteed to be selectable by the gateway. </p>
</li>
<li>
<p>The <code>requires</code> directive is used to annotate the required input fieldset from a base type for a resolver. It is used to develop a query plan where the required fields may not be needed by the client, but the service may need additional information from other services.</p>
</li>
</ul>
<h2 id="entity-lookup-function"><a class="header" href="#entity-lookup-function">Entity lookup function</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Query;

#[Object]
impl Query {
    #[entity]
    async fn find_user_by_id(&amp;self, id: ID) -&gt; User {
        User { ... }
    }

    #[entity]
    async fn find_user_by_id_with_username(&amp;self, #[graphql(key)] id: ID, username: String) -&gt; User {
        User { ... }
    }

    #[entity]
    async fn find_user_by_id_and_username(&amp;self, id: ID, username: String) -&gt; User {
        User { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Notice the difference between these three lookup functions, which are all looking for the <code>User</code> object.</strong></p>
<ul>
<li>
<p><code>find_user_by_id</code></p>
<p>Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>.</p>
</li>
<li>
<p><code>find_user_by_id_with_username</code></p>
<p>Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>, and the <code>username</code> field value of the <code>User</code> object is requested.</p>
</li>
<li>
<p><code>find_user_by_id_and_username</code></p>
<p>Use <code>id</code> and <code>username</code> to find an <code>User</code> object, the keys for <code>User</code> are <code>id</code> and <code>username</code>.</p>
</li>
</ul>
<p>For a complete example, refer to: <a href="https://github.com/async-graphql/examples/tree/master/federation">https://github.com/async-graphql/examples/tree/master/federation</a>.</p>
<h2 id="defining-a-compound-primary-key"><a class="header" href="#defining-a-compound-primary-key">Defining a compound primary key</a></h2>
<p>A single primary key can consist of multiple fields, and even nested fields, you can use <code>InputObject</code> to implements a nested primary key.</p>
<p>In the following example, the primary key of the <code>User</code> object is <code>key { a b }</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(InputObject)]
struct NestedKey {
  a: i32,
  b: i32,
}

struct Query;

#[Object]
impl Query {
  #[entity]
  async fn find_user_by_key(&amp;self, key: NestedKey) -&gt; User {
    User { ... }
  }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
